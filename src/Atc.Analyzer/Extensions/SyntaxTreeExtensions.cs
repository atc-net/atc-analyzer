// ReSharper disable ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
// ReSharper disable ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
namespace Atc.Analyzer.Extensions;

/// <summary>
/// Extension methods for <see cref="SyntaxTree"/>.
/// </summary>
public static class SyntaxTreeExtensions
{
    /// <summary>
    /// Determines whether the syntax tree represents an auto-generated file.
    /// </summary>
    /// <param name="syntaxTree">The syntax tree to check.</param>
    /// <returns>
    /// <c>true</c> if the file contains "auto-generated" or "autogenerated" in its leading comments (case-insensitive);
    /// otherwise, <c>false</c>.
    /// </returns>
    /// <remarks>
    /// This method checks both single-line and multi-line comments at the beginning of the file
    /// for the presence of "auto-generated" or "autogenerated" text. This is commonly used to identify files
    /// generated by code generators such as T4 templates, API generators, etc.
    /// </remarks>
    public static bool IsAutoGeneratedFile(this SyntaxTree syntaxTree)
    {
        if (syntaxTree is null)
        {
            return false;
        }

        var root = syntaxTree.GetRoot();
        var leadingTrivia = root.GetLeadingTrivia();

        foreach (var trivia in leadingTrivia)
        {
            if (!trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) &&
                !trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
            {
                continue;
            }

            var commentText = trivia.ToString();
            if (commentText.IndexOf("auto-generated", StringComparison.OrdinalIgnoreCase) >= 0 ||
                commentText.IndexOf("autogenerated", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Gets the end-of-line trivia used in the syntax tree, detecting the existing line ending style.
    /// </summary>
    /// <param name="syntaxTree">The syntax tree to analyze.</param>
    /// <returns>
    /// The first end-of-line trivia found in the tree, or <see cref="SyntaxFactory.LineFeed"/> if none is found.
    /// </returns>
    /// <remarks>
    /// This method is useful for code fixes to maintain consistent line endings with the existing file.
    /// It searches for the first end-of-line trivia in the tree and returns it, ensuring the generated
    /// code matches the existing line ending style (\r\n on Windows or \n on Unix/Linux/macOS).
    /// </remarks>
    public static SyntaxTrivia GetEndOfLineTrivia(this SyntaxTree syntaxTree)
    {
        if (syntaxTree is null)
        {
            return SyntaxFactory.LineFeed;
        }

        var root = syntaxTree.GetRoot();
        var endOfLine = root
            .DescendantTrivia()
            .FirstOrDefault(t => t.IsKind(SyntaxKind.EndOfLineTrivia));

        // Fallback to Unix-style line ending if none found
        return endOfLine == default
            ? SyntaxFactory.LineFeed
            : endOfLine;
    }

    /// <summary>
    /// Gets the end-of-line trivia used in the syntax node, detecting the existing line ending style.
    /// </summary>
    /// <param name="node">The syntax node to analyze.</param>
    /// <returns>
    /// The first end-of-line trivia found in the node or its ancestors' tree, or <see cref="SyntaxFactory.LineFeed"/> if none is found.
    /// </returns>
    /// <remarks>
    /// This method is useful for code fixes to maintain consistent line endings with the existing file.
    /// It searches for the first end-of-line trivia in the tree and returns it, ensuring the generated
    /// code matches the existing line ending style (\r\n on Windows or \n on Unix/Linux/macOS).
    /// </remarks>
    public static SyntaxTrivia GetEndOfLineTrivia(this SyntaxNode node)
    {
        if (node is null)
        {
            return SyntaxFactory.LineFeed;
        }

        var syntaxTree = node.SyntaxTree;
        return syntaxTree?.GetEndOfLineTrivia() ?? SyntaxFactory.LineFeed;
    }
}