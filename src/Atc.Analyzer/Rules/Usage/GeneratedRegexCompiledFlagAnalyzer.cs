namespace Atc.Analyzer.Rules.Usage;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class GeneratedRegexCompiledFlagAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Usage.GeneratedRegexCompiledFlag,
        title: "Remove redundant RegexOptions.Compiled flag from [GeneratedRegex] attribute",
        messageFormat: "The RegexOptions.Compiled flag is redundant for [GeneratedRegex] attributes as they are already compiled at build time",
        RuleCategoryConstants.Usage,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "The [GeneratedRegex] attribute generates compiled regex code at build time using source generators. Adding RegexOptions.Compiled to the options parameter is redundant and has no effect, as the generated regex is already compiled.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Usage.GeneratedRegexCompiledFlag));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK.")]
    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;

        // Find GeneratedRegex attribute
        AttributeSyntax? generatedRegexAttribute = null;
        foreach (var attributeList in methodDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var attributeName = attribute.Name.ToString();
                if (!attributeName.Contains("GeneratedRegex"))
                {
                    continue;
                }

                // Check if this is actually the GeneratedRegex attribute via semantic model
                var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute, context.CancellationToken);
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol &&
                    methodSymbol.ContainingType?.ToDisplayString() == "System.Text.RegularExpressions.GeneratedRegexAttribute")
                {
                    generatedRegexAttribute = attribute;
                    break;
                }
            }

            if (generatedRegexAttribute is not null)
            {
                break;
            }
        }

        if (generatedRegexAttribute is null)
        {
            return;
        }

        var attributeSyntax = generatedRegexAttribute;

        // Get the attribute arguments
        if (attributeSyntax.ArgumentList is null)
        {
            return;
        }

        // Find the options parameter (second parameter or named parameter)
        AttributeArgumentSyntax? optionsArgument = null;

        // Check for named parameter "options"
        foreach (var argument in attributeSyntax.ArgumentList.Arguments)
        {
            if (argument.NameEquals?.Name.Identifier.Text == "options")
            {
                optionsArgument = argument;
                break;
            }
        }

        // If not found as named parameter, check for second positional parameter
        if (optionsArgument is null && attributeSyntax.ArgumentList.Arguments.Count >= 2)
        {
            optionsArgument = attributeSyntax.ArgumentList.Arguments[1];
        }

        if (optionsArgument is null)
        {
            return;
        }

        // Check if the options expression contains RegexOptions.Compiled
        var containsCompiled = ContainsRegexOptionsCompiled(context, optionsArgument.Expression);
        if (!containsCompiled.HasValue || !containsCompiled.Value)
        {
            return;
        }

        // Find the exact location of RegexOptions.Compiled in the expression
        var compiledLocation = FindCompiledFlagLocation(context, optionsArgument.Expression);
        if (compiledLocation is null)
        {
            // Fallback to the entire options argument
            compiledLocation = optionsArgument.GetLocation();
        }

        var diagnostic = Diagnostic.Create(Rule, compiledLocation);
        context.ReportDiagnostic(diagnostic);
    }

    private static bool? ContainsRegexOptionsCompiled(SyntaxNodeAnalysisContext context, ExpressionSyntax expression)
    {
        // Check if this is a simple member access: RegexOptions.Compiled
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(memberAccess, context.CancellationToken);
            if (symbolInfo.Symbol is IFieldSymbol fieldSymbol)
            {
                return fieldSymbol.ContainingType?.ToDisplayString() == "System.Text.RegularExpressions.RegexOptions"
                    && fieldSymbol.Name == "Compiled";
            }
        }

        // Check if this is a binary expression with OR operator
        if (expression is BinaryExpressionSyntax binaryExpression && binaryExpression.IsKind(SyntaxKind.BitwiseOrExpression))
        {
            var leftContains = ContainsRegexOptionsCompiled(context, binaryExpression.Left);
            var rightContains = ContainsRegexOptionsCompiled(context, binaryExpression.Right);

            return (leftContains.HasValue && leftContains.Value) || (rightContains.HasValue && rightContains.Value);
        }

        // Check if this is a cast expression
        if (expression is CastExpressionSyntax castExpression)
        {
            return ContainsRegexOptionsCompiled(context, castExpression.Expression);
        }

        // Check if this is a parenthesized expression
        if (expression is ParenthesizedExpressionSyntax parenthesizedExpression)
        {
            return ContainsRegexOptionsCompiled(context, parenthesizedExpression.Expression);
        }

        return false;
    }

    private static Location? FindCompiledFlagLocation(SyntaxNodeAnalysisContext context, ExpressionSyntax expression)
    {
        // Check if this is a simple member access: RegexOptions.Compiled
        if (expression is MemberAccessExpressionSyntax memberAccess)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(memberAccess, context.CancellationToken);
            if (symbolInfo.Symbol is IFieldSymbol fieldSymbol
                && fieldSymbol.ContainingType?.ToDisplayString() == "System.Text.RegularExpressions.RegexOptions"
                && fieldSymbol.Name == "Compiled")
            {
                return memberAccess.GetLocation();
            }
        }

        // Check if this is a binary expression with OR operator
        if (expression is BinaryExpressionSyntax binaryExpression && binaryExpression.IsKind(SyntaxKind.BitwiseOrExpression))
        {
            var leftLocation = FindCompiledFlagLocation(context, binaryExpression.Left);
            if (leftLocation is not null)
            {
                return leftLocation;
            }

            var rightLocation = FindCompiledFlagLocation(context, binaryExpression.Right);
            if (rightLocation is not null)
            {
                return rightLocation;
            }
        }

        // Check if this is a cast expression
        if (expression is CastExpressionSyntax castExpression)
        {
            return FindCompiledFlagLocation(context, castExpression.Expression);
        }

        // Check if this is a parenthesized expression
        if (expression is ParenthesizedExpressionSyntax parenthesizedExpression)
        {
            return FindCompiledFlagLocation(context, parenthesizedExpression.Expression);
        }

        return null;
    }
}