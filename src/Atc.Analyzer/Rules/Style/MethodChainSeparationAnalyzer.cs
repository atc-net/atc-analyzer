// ReSharper disable ConvertIfStatementToSwitchStatement
// ReSharper disable InvertIf
namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class MethodChainSeparationAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.MethodChainSeparation,
        title: "Method chains with 2 or more calls should be placed on separate lines",
        messageFormat: "Method chains with 2 or more calls should be broken down to separate lines",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Info,
        isEnabledByDefault: true,
        description: "Ensures consistent method chain formatting. When chaining 2 or more method calls, each method should be on a separate line for better readability.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.MethodChainSeparation));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeInvocationExpression, SyntaxKind.InvocationExpression);
    }

    private static void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var invocationExpression = (InvocationExpressionSyntax)context.Node;

        if (!ShouldAnalyzeMethodChain(invocationExpression, out var invocationNodes, context))
        {
            return;
        }

        var invocationLines = invocationNodes.GetInvocationLines();

        if (AreAllMethodsOnSameLine(invocationLines))
        {
            ReportDiagnostic(context, invocationExpression);
            return;
        }

        if (HasInconsistentMultiLineFormatting(invocationNodes, invocationLines))
        {
            ReportDiagnostic(context, invocationExpression);
        }
    }

    private static void ReportDiagnostic(
        SyntaxNodeAnalysisContext context,
        InvocationExpressionSyntax invocationExpression)
    {
        // Check if the invocation is wrapped in an await expression
        // If so, report the diagnostic on the await expression to include the await keyword
        var diagnosticLocation = invocationExpression.GetLocation();
        if (invocationExpression.Parent is AwaitExpressionSyntax awaitExpression)
        {
            diagnosticLocation = awaitExpression.GetLocation();
        }

        var diagnostic = Diagnostic.Create(Rule, diagnosticLocation);
        context.ReportDiagnostic(diagnostic);
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK.")]
    private static bool ShouldAnalyzeMethodChain(
        InvocationExpressionSyntax invocationExpression,
        out List<InvocationExpressionSyntax> invocationNodes,
        SyntaxNodeAnalysisContext context)
    {
        invocationNodes = [];

        // Find the root of the method chain
        var chainRoot = invocationExpression.GetMethodChainRoot();

        // If this isn't the outermost invocation in a chain, skip it
        if (chainRoot != invocationExpression)
        {
            return false;
        }

        // Get all invocations in the chain and their line positions
        var allInvocationNodes = invocationExpression.GetInvocationNodes();

        // Filter to only count "chained" method calls
        // A method call is part of the chain if:
        // 1. It's accessed via member access (e.g., .ToString(), .Trim()), OR
        // 2. It's a parameterless method call (e.g., GetDataAsync())
        // A method call with arguments (e.g., MethodA(value)) is considered the base expression, not part of the chain
        invocationNodes = allInvocationNodes
            .Where(inv => inv.Expression is MemberAccessExpressionSyntax || inv.ArgumentList.Arguments.Count == 0)
            .ToList();

        // Get the configurable minimum chain length from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(invocationExpression.SyntaxTree);
        var minChainLength = options.GetMinChainLength(RuleIdentifierConstants.Style.MethodChainSeparation);

        // We only care about chains with minChainLength or more method calls
        if (invocationNodes.Count < minChainLength)
        {
            return false;
        }

        // Special case for FluentAssertions: Allow "actual.Should().Be(...)" pattern on one line
        // If there are exactly 2 method calls and the first one is "Should", skip analysis
        if (invocationNodes.Count == 2 && invocationNodes.IsFluentAssertionsShouldPattern())
        {
            return false;
        }

        // Special case for method calls starting with a method: Allow "Method1().Method2()" on one line
        // If there are exactly 2 method calls and the chain starts with a method call (not a variable/property),
        // this is acceptable on a single line
        if (invocationNodes.Count == 2)
        {
            var baseExpression = invocationExpression.GetBaseExpression();

            // If base expression is an invocation, it's definitely starting with a method call
            if (baseExpression is InvocationExpressionSyntax)
            {
                return false;
            }

            // If base expression is an identifier, check if it's a type (static method call) vs variable/property
            if (baseExpression is IdentifierNameSyntax identifier)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(identifier);
                var symbol = symbolInfo.Symbol;

                // If it's a type (class/struct/interface), it's a static method call - allow it
                // If it's a local variable, parameter, field, or property - it's starting from an instance - disallow it
                if (symbol is INamedTypeSymbol)
                {
                    return false;
                }
            }

            // Special case for if-statement conditions: Allow 2-method chains in if-statement conditions
            // This allows readable conditions like: if (rootElement.Attributes("Sdk").Count() == 1)
            if (IsInIfStatementCondition(invocationExpression))
            {
                return false;
            }
        }

        return true;
    }

    private static bool IsInIfStatementCondition(InvocationExpressionSyntax invocationExpression)
    {
        if (invocationExpression is null)
        {
            throw new ArgumentNullException(nameof(invocationExpression));
        }

        // Walk up the syntax tree to find if we're inside an if-statement condition
        var current = invocationExpression.Parent;
        while (current is not null)
        {
            // If we find an if-statement, check if our invocation is part of the condition
            if (current is IfStatementSyntax ifStatement)
            {
                // Check if the invocation is a descendant of the condition
                return ifStatement.Condition.Contains(invocationExpression);
            }

            // If we reach a statement or member declaration, we're no longer in a condition context
            if (current is StatementSyntax && current is not IfStatementSyntax)
            {
                return false;
            }

            current = current.Parent;
        }

        return false;
    }

    private static bool AreAllMethodsOnSameLine(List<int> invocationLines)
    {
        var firstLine = invocationLines[0];
        return invocationLines.All(line => line == firstLine);
    }

    private static bool HasInconsistentMultiLineFormatting(
        List<InvocationExpressionSyntax> invocationNodes,
        List<int> invocationLines)
    {
        // If methods span multiple lines, check if the base expression and first method
        // are on the same line. They should be on separate lines for proper formatting.
        // Get the innermost invocation (last in the list)
        var innermostInvocation = invocationNodes[invocationNodes.Count - 1];
        var baseExpression = innermostInvocation.GetBaseExpression();

        if (baseExpression is null)
        {
            return false;
        }

        var baseExpressionLine = baseExpression.GetLocation().GetLineSpan().StartLinePosition.Line;
        var firstMethodLine = invocationLines[invocationLines.Count - 1]; // Last element is the first method in the chain

        // If base expression and first method are on the same line, but there are
        // subsequent methods on different lines, this is inconsistent formatting
        return baseExpressionLine == firstMethodLine;
    }
}