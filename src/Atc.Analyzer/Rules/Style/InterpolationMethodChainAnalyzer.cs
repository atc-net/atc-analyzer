namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class InterpolationMethodChainAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.InterpolationMethodChain,
        title: "Chained method calls in interpolated strings should be simplified",
        messageFormat: "Consider extracting {0} chained method calls to a variable or extension method for improved readability",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Info,
        isEnabledByDefault: true,
        description: "Suggests simplifying chained method calls within string interpolation expressions by extracting them to a variable or creating an extension method.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.InterpolationMethodChain));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeInterpolation, SyntaxKind.Interpolation);
    }

    private static void AnalyzeInterpolation(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var interpolation = (InterpolationSyntax)context.Node;

        // Get all invocation expressions directly within this interpolation
        // (excluding those in nested interpolated strings)
        var invocations = interpolation.DescendantNodes()
            .OfType<InvocationExpressionSyntax>()
            .Where(inv => !IsInNestedInterpolation(inv, interpolation))
            .ToList();

        if (invocations.Count == 0)
        {
            return;
        }

        // Find the outermost (root) invocation in each chain
        var chainRoots = invocations
            .Where(inv => !invocations.Any(other => other != inv && other.DescendantNodes().Contains(inv)))
            .ToList();

        foreach (var chainRoot in chainRoots)
        {
            var chainedMethodCount = CountChainedMethods(chainRoot);

            if (chainedMethodCount >= 2)
            {
                var diagnostic = Diagnostic.Create(
                    Rule,
                    chainRoot.GetLocation(),
                    chainedMethodCount);
                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private static bool IsInNestedInterpolation(InvocationExpressionSyntax invocation, InterpolationSyntax parentInterpolation)
    {
        // Check if the invocation is inside a nested InterpolationSyntax
        // (different from the parent we're currently analyzing)
        var current = invocation.Parent;
        while (current is not null && current != parentInterpolation)
        {
            if (current is InterpolationSyntax)
            {
                return true;
            }

            current = current.Parent;
        }

        return false;
    }

    private static int CountChainedMethods(InvocationExpressionSyntax invocation)
    {
        var count = 0;
        var current = invocation.Expression;

        while (current is not null)
        {
            if (current is MemberAccessExpressionSyntax memberAccess)
            {
                // Check if this member access leads to an invocation
                if (invocation.Expression == current ||
                    IsPartOfInvocationChain(memberAccess, invocation))
                {
                    count++;
                }

                current = memberAccess.Expression;
            }
            else if (current is InvocationExpressionSyntax nestedInvocation)
            {
                // Continue traversing through the nested invocation
                current = nestedInvocation.Expression;
            }
            else
            {
                break;
            }
        }

        return count;
    }

    private static bool IsPartOfInvocationChain(MemberAccessExpressionSyntax memberAccess, InvocationExpressionSyntax rootInvocation)
    {
        // Check if this member access is part of an invocation expression in the chain
        var parent = memberAccess.Parent;
        while (parent is not null && parent != rootInvocation.Parent)
        {
            if (parent is InvocationExpressionSyntax)
            {
                return true;
            }

            parent = parent.Parent;
        }

        return false;
    }
}
