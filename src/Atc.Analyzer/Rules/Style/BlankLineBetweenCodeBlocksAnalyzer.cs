namespace Atc.Analyzer.Rules.Style;

/// <summary>
/// Analyzer that enforces exactly one blank line between consecutive code blocks.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class BlankLineBetweenCodeBlocksAnalyzer : DiagnosticAnalyzer
{
    private const string MissingBlankLineMessage = "Add a blank line between consecutive code blocks for readability";
    private const string ExcessiveBlankLinesMessage = "Remove extra blank lines between code blocks (should have exactly one)";

    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.BlankLineBetweenCodeBlocks,
        title: "Require exactly one blank line between code blocks",
        messageFormat: "{0}",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Consecutive code blocks should be separated by exactly one blank line for improved readability.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.BlankLineBetweenCodeBlocks));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics
        => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeBlock, SyntaxKind.Block);
    }

    private static void AnalyzeBlock(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var block = (BlockSyntax)context.Node;
        var statements = block.Statements;

        if (statements.Count < 2)
        {
            return;
        }

        for (var i = 0; i < statements.Count - 1; i++)
        {
            var first = statements[i];
            var second = statements[i + 1];

            // Only check pairs where both are block statements
            if (!IsBlockStatement(first) || !IsBlockStatement(second))
            {
                continue;
            }

            var blankLineCount = CountBlankLinesBetween(first, second);

            if (blankLineCount == 0)
            {
                // Missing blank line
                var diagnostic = Diagnostic.Create(
                    Rule,
                    second.GetLocation(),
                    MissingBlankLineMessage);
                context.ReportDiagnostic(diagnostic);
            }
            else if (blankLineCount > 1)
            {
                // Too many blank lines
                var diagnostic = Diagnostic.Create(
                    Rule,
                    second.GetLocation(),
                    ExcessiveBlankLinesMessage);
                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private static bool IsBlockStatement(StatementSyntax statement)
    {
        return statement is IfStatementSyntax
            or ForStatementSyntax
            or ForEachStatementSyntax
            or WhileStatementSyntax
            or DoStatementSyntax
            or SwitchStatementSyntax
            or TryStatementSyntax
            or UsingStatementSyntax
            or LockStatementSyntax
            or FixedStatementSyntax
            or CheckedStatementSyntax;
    }

    private static int CountBlankLinesBetween(
        StatementSyntax first,
        StatementSyntax second)
    {
        // Get the end line of the first statement
        var firstEndLine = first
            .GetLocation()
            .GetLineSpan()
            .EndLinePosition
            .Line;

        // Get the start line of the second statement (or its first non-whitespace leading trivia)
        var secondStartLine = GetEffectiveStartLine(second);

        // The number of blank lines is the gap between lines minus 1
        // If first ends at line 5 and second starts at line 7, there's 1 blank line (line 6)
        // If first ends at line 5 and second starts at line 6, there's 0 blank lines
        return Math.Max(0, secondStartLine - firstEndLine - 1);
    }

    private static int GetEffectiveStartLine(StatementSyntax statement)
    {
        // Check leading trivia for comments or preprocessor directives - if found, use its line position
        var leadingTrivia = statement.GetLeadingTrivia();

        foreach (var trivia in leadingTrivia)
        {
            if (trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) ||
                trivia.IsKind(SyntaxKind.MultiLineCommentTrivia) ||
                trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) ||
                trivia.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia) ||
                trivia.IsKind(SyntaxKind.IfDirectiveTrivia) ||
                trivia.IsKind(SyntaxKind.ElseDirectiveTrivia) ||
                trivia.IsKind(SyntaxKind.ElifDirectiveTrivia) ||
                trivia.IsKind(SyntaxKind.EndIfDirectiveTrivia) ||
                trivia.IsKind(SyntaxKind.RegionDirectiveTrivia) ||
                trivia.IsKind(SyntaxKind.EndRegionDirectiveTrivia))
            {
                // Return the line where the trivia starts
                return trivia
                           .GetLocation()?
                           .GetLineSpan()
                           .StartLinePosition
                           .Line
                    ?? statement
                        .GetLocation()
                        .GetLineSpan()
                        .StartLinePosition.Line;
            }
        }

        return statement
            .GetLocation()
            .GetLineSpan()
            .StartLinePosition
            .Line;
    }
}