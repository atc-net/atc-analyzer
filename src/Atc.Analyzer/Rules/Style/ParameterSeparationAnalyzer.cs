namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class ParameterSeparationAnalyzer : DiagnosticAnalyzer
{
    private const int MaxLineLengthForSingleParam = 80;

    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.ParameterSeparation,
        title: "Multi parameters should be separated onto individual lines",
        messageFormat: "Multi parameters should be broken down to separate lines",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Ensures consistent parameter formatting across method declarations. Parameters should be on separate lines for methods with multiple parameters or when the total line length exceeds the limit.",
        helpLinkUri: "https://github.com/atc-net/atc-analyzer/blob/main/docs/rules/ATC202.md");

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // Register for method declarations
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);

        // Register for constructor declarations
        context.RegisterSyntaxNodeAction(AnalyzeConstructorDeclaration, SyntaxKind.ConstructorDeclaration);

        // Register for local function declarations
        context.RegisterSyntaxNodeAction(AnalyzeLocalFunctionDeclaration, SyntaxKind.LocalFunctionStatement);

        // Register for delegate declarations
        context.RegisterSyntaxNodeAction(AnalyzeDelegateDeclaration, SyntaxKind.DelegateDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, methodDeclaration.ParameterList);
    }

    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var constructorDeclaration = (ConstructorDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, constructorDeclaration.ParameterList);
    }

    private static void AnalyzeLocalFunctionDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var localFunctionDeclaration = (LocalFunctionStatementSyntax)context.Node;
        AnalyzeParameterList(context, localFunctionDeclaration.ParameterList);
    }

    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var delegateDeclaration = (DelegateDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, delegateDeclaration.ParameterList);
    }

    private static void AnalyzeParameterList(
        SyntaxNodeAnalysisContext context,
        ParameterListSyntax parameterList)
    {
        if (parameterList is null || parameterList.Parameters.Count == 0)
        {
            return;
        }

        var parameters = parameterList.Parameters;
        var sourceText = context.Node.SyntaxTree.GetText();

        // Rule 1: Multiple parameters (2 or more) should be on separate lines
        if (parameters.Count >= 2)
        {
            if (!AreParametersOnSeparateLines(parameters))
            {
                var diagnostic = Diagnostic.Create(
                    Rule,
                    parameterList.GetLocation());
                context.ReportDiagnostic(diagnostic);
            }
        }

        // Rule 2: Single parameter - check if line length exceeds 80 characters
        else if (parameters.Count == 1)
        {
            var lineSpan = context.Node.GetLocation().GetLineSpan();
            var startLine = lineSpan.StartLinePosition.Line;
            var textLine = sourceText.Lines[startLine];
            var lineText = textLine.ToString();

            // Check if total line length exceeds 80 characters
            if (lineText.Length > MaxLineLengthForSingleParam)
            {
                // Check if parameter is already on a separate line
                var paramLocation = parameters[0].GetLocation().GetLineSpan();
                var paramLine = paramLocation.StartLinePosition.Line;

                // If parameter is on the same line as the declaration start, it needs to be broken
                if (paramLine == startLine)
                {
                    var diagnostic = Diagnostic.Create(
                        Rule,
                        parameterList.GetLocation());
                    context.ReportDiagnostic(diagnostic);
                }
            }
        }
    }

    private static bool AreParametersOnSeparateLines(
        SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        if (parameters.Count < 2)
        {
            return true;
        }

        // Check if all parameters are on different lines
        var firstParamLine = parameters[0].GetLocation().GetLineSpan().StartLinePosition.Line;

        for (var i = 1; i < parameters.Count; i++)
        {
            var currentParamLine = parameters[i].GetLocation().GetLineSpan().StartLinePosition.Line;

            // If any parameter is on the same line as the first parameter, they're not properly separated
            if (currentParamLine == firstParamLine)
            {
                return false;
            }

            // Each parameter should be on a different line from the previous one
            var previousParamLine = parameters[i - 1].GetLocation().GetLineSpan().StartLinePosition.Line;
            if (currentParamLine == previousParamLine)
            {
                return false;
            }
        }

        return true;
    }
}