namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class ParameterSeparationAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.ParameterSeparation,
        title: "Multi parameters should be separated on individual lines",
        messageFormat: "Multi parameters should be broken down to separate lines",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Ensures consistent parameter formatting across method declarations. Parameters should be on separate lines for methods with multiple parameters or when the total line length exceeds the limit.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.ParameterSeparation));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // Register for method declarations
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);

        // Register for constructor declarations
        context.RegisterSyntaxNodeAction(AnalyzeConstructorDeclaration, SyntaxKind.ConstructorDeclaration);

        // Register for local function declarations
        context.RegisterSyntaxNodeAction(AnalyzeLocalFunctionDeclaration, SyntaxKind.LocalFunctionStatement);

        // Register for delegate declarations
        context.RegisterSyntaxNodeAction(AnalyzeDelegateDeclaration, SyntaxKind.DelegateDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, methodDeclaration.ParameterList);
    }

    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var constructorDeclaration = (ConstructorDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, constructorDeclaration.ParameterList);
    }

    private static void AnalyzeLocalFunctionDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var localFunctionDeclaration = (LocalFunctionStatementSyntax)context.Node;
        AnalyzeParameterList(context, localFunctionDeclaration.ParameterList);
    }

    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var delegateDeclaration = (DelegateDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, delegateDeclaration.ParameterList);
    }

    private static void AnalyzeParameterList(
        SyntaxNodeAnalysisContext context,
        ParameterListSyntax parameterList)
    {
        if (parameterList is null || parameterList.Parameters.Count == 0)
        {
            return;
        }

        var parameters = parameterList.Parameters;

        // Get the configurable minimum parameter count from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(context.Node.SyntaxTree);
        var minParamCount = options.GetMinParameterCount(RuleIdentifierConstants.Style.ParameterSeparation);

        // ATC202: Only handles multiple parameters (minParamCount or more) - they should be on separate lines
        // Note: Single parameter scenarios are handled by ATC201 (ParameterInlineAnalyzer)
        if (parameters.Count >= minParamCount && !AreParametersOnSeparateLines(parameters))
        {
            var diagnostic = Diagnostic.Create(
                Rule,
                parameterList.GetLocation());
            context.ReportDiagnostic(diagnostic);
        }
    }

    private static bool AreParametersOnSeparateLines(
        SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        if (parameters.Count < 2)
        {
            return true;
        }

        // Check if all parameters are on different lines
        var firstParamLine = parameters[0].GetLocation().GetLineSpan().StartLinePosition.Line;

        for (var i = 1; i < parameters.Count; i++)
        {
            var currentParamLine = parameters[i].GetLocation().GetLineSpan().StartLinePosition.Line;

            // If any parameter is on the same line as the first parameter, they're not properly separated
            if (currentParamLine == firstParamLine)
            {
                return false;
            }

            // Each parameter should be on a different line from the previous one
            var previousParamLine = parameters[i - 1].GetLocation().GetLineSpan().StartLinePosition.Line;
            if (currentParamLine == previousParamLine)
            {
                return false;
            }
        }

        return true;
    }
}