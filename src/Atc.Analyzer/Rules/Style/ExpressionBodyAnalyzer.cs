namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class ExpressionBodyAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.ExpressionBody,
        title: "Use expression body syntax when appropriate",
        messageFormat: "{0}",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Methods and properties with simple return statements should use expression body syntax (=>) for conciseness. Expression bodies longer than the configured maximum should place the arrow on a new line.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.ExpressionBody));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);
        context.RegisterSyntaxNodeAction(AnalyzePropertyDeclaration, SyntaxKind.PropertyDeclaration);
        context.RegisterSyntaxNodeAction(AnalyzeAccessorDeclaration, SyntaxKind.GetAccessorDeclaration);
        context.RegisterSyntaxNodeAction(AnalyzeAccessorDeclaration, SyntaxKind.SetAccessorDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;

        // Check if method should use expression body
        if (methodDeclaration.Body is not null && methodDeclaration.ExpressionBody is null)
        {
            AnalyzeBlockBody(context, methodDeclaration.Body, methodDeclaration.Identifier);
        }

        // Check if existing expression body is formatted correctly
        if (methodDeclaration.ExpressionBody is not null)
        {
            AnalyzeExpressionBodyFormatting(context, methodDeclaration, methodDeclaration.Identifier);
        }
    }

    private static void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var propertyDeclaration = (PropertyDeclarationSyntax)context.Node;

        // Check if existing expression body is formatted correctly
        if (propertyDeclaration.ExpressionBody is not null)
        {
            AnalyzeExpressionBodyFormatting(context, propertyDeclaration, propertyDeclaration.Identifier);
        }
    }

    private static void AnalyzeAccessorDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var accessorDeclaration = (AccessorDeclarationSyntax)context.Node;

        // Check if accessor should use expression body
        if (accessorDeclaration.Body is not null && accessorDeclaration.ExpressionBody is null)
        {
            AnalyzeBlockBody(context, accessorDeclaration.Body, accessorDeclaration.Keyword);
        }

        // Check if existing expression body is formatted correctly
        if (accessorDeclaration.ExpressionBody is not null)
        {
            AnalyzeAccessorExpressionBodyFormatting(context, accessorDeclaration);
        }
    }

    private static void AnalyzeBlockBody(
        SyntaxNodeAnalysisContext context,
        BlockSyntax body,
        SyntaxToken identifier)
    {
        // Check if body has exactly one statement that is a return statement
        if (body.Statements.Count != 1)
        {
            return;
        }

        if (body.Statements[0] is not ReturnStatementSyntax returnStatement)
        {
            return;
        }

        // Check if return has an expression (not just "return;")
        if (returnStatement.Expression is null)
        {
            return;
        }

        // Report diagnostic suggesting to use expression body
        var diagnostic = Diagnostic.Create(
            Rule,
            identifier.GetLocation(),
            "Use expression body syntax instead of block body with single return statement");

        context.ReportDiagnostic(diagnostic);
    }

    private static void AnalyzeExpressionBodyFormatting(
        SyntaxNodeAnalysisContext context,
        SyntaxNode declarationNode,
        SyntaxToken identifier)
    {
        var sourceText = declarationNode.SyntaxTree.GetText();

        // Get the configured max line length from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(context.Node.SyntaxTree);
        var maxLineLength = options.GetMaxLineLength(RuleIdentifierConstants.Style.ExpressionBody);

        // Get the ArrowExpressionClause
        ArrowExpressionClauseSyntax? arrowExpression = declarationNode switch
        {
            MethodDeclarationSyntax method => method.ExpressionBody,
            PropertyDeclarationSyntax property => property.ExpressionBody,
            _ => null,
        };

        if (arrowExpression is null)
        {
            return;
        }

        var arrowToken = arrowExpression.ArrowToken;
        var expression = arrowExpression.Expression;

        var lineInfo = GetLineInfo(sourceText, arrowToken, identifier, expression);
        var hasComplexExpression = expression is ConditionalExpressionSyntax;

        if (lineInfo.ArrowLineNumber == lineInfo.IdentifierLineNumber)
        {
            CheckSameLineFormatting(context, arrowToken, lineInfo, hasComplexExpression, maxLineLength);
        }
    }

    private static LineInfo GetLineInfo(
        Microsoft.CodeAnalysis.Text.SourceText sourceText,
        SyntaxToken arrowToken,
        SyntaxToken identifier,
        ExpressionSyntax expression)
    {
        var arrowLine = sourceText.Lines.GetLineFromPosition(arrowToken.SpanStart);
        var identifierLine = sourceText.Lines.GetLineFromPosition(identifier.SpanStart);
        var expressionLine = sourceText.Lines.GetLineFromPosition(expression.SpanStart);

        return new LineInfo(
            arrowLine.LineNumber,
            identifierLine.LineNumber,
            expressionLine.LineNumber,
            arrowLine.ToString().TrimEnd().Length);
    }

    private static void CheckSameLineFormatting(
        SyntaxNodeAnalysisContext context,
        SyntaxToken arrowToken,
        LineInfo lineInfo,
        bool hasComplexExpression,
        int maxLineLength)
    {
        if (lineInfo.DeclarationLineLength > maxLineLength)
        {
            var diagnostic = Diagnostic.Create(
                Rule,
                arrowToken.GetLocation(),
                $"Expression body exceeds {maxLineLength} characters, move '=>' to a new line");

            context.ReportDiagnostic(diagnostic);
            return;
        }

        if (lineInfo.ExpressionLineNumber > lineInfo.ArrowLineNumber && hasComplexExpression)
        {
            var diagnostic = Diagnostic.Create(
                Rule,
                arrowToken.GetLocation(),
                "For multi-line expressions, move '=>' to a new line");

            context.ReportDiagnostic(diagnostic);
        }
    }

    private static void AnalyzeAccessorExpressionBodyFormatting(
        SyntaxNodeAnalysisContext context,
        AccessorDeclarationSyntax accessorDeclaration)
    {
        if (accessorDeclaration.ExpressionBody is null)
        {
            return;
        }

        // Get the configured max line length from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(context.Node.SyntaxTree);
        var maxLineLength = options.GetMaxLineLength(RuleIdentifierConstants.Style.ExpressionBody);

        var sourceText = accessorDeclaration.SyntaxTree.GetText();
        var arrowToken = accessorDeclaration.ExpressionBody.ArrowToken;
        var expression = accessorDeclaration.ExpressionBody.Expression;

        // Get lines
        var arrowLine = sourceText.Lines.GetLineFromPosition(arrowToken.SpanStart);
        var arrowLineNumber = arrowLine.LineNumber;

        var keywordLine = sourceText.Lines.GetLineFromPosition(accessorDeclaration.Keyword.SpanStart);
        var keywordLineNumber = keywordLine.LineNumber;

        var expressionLine = sourceText.Lines.GetLineFromPosition(expression.SpanStart);
        var expressionLineNumber = expressionLine.LineNumber;

        var hasComplexExpression = expression is ConditionalExpressionSyntax;

        if (arrowLineNumber == keywordLineNumber)
        {
            var declarationLineText = arrowLine.ToString();
            var declarationLineLength = declarationLineText.TrimEnd().Length;

            if (declarationLineLength > maxLineLength)
            {
                var diagnostic = Diagnostic.Create(
                    Rule,
                    arrowToken.GetLocation(),
                    $"Expression body exceeds {maxLineLength} characters, move '=>' to a new line");

                context.ReportDiagnostic(diagnostic);
                return;
            }

            if (expressionLineNumber > arrowLineNumber && hasComplexExpression)
            {
                var diagnostic = Diagnostic.Create(
                    Rule,
                    arrowToken.GetLocation(),
                    "For multi-line expressions, move '=>' to a new line");

                context.ReportDiagnostic(diagnostic);
            }
        }
    }
}