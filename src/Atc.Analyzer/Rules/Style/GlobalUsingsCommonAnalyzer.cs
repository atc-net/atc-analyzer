// ReSharper disable InvertIf
namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class GlobalUsingsCommonAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.GlobalUsingsCommon,
        title: "Use global usings for common namespaces",
        messageFormat: "Using directive '{0}' should be moved to GlobalUsings.cs",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Using directives for System, Microsoft, and Atc namespaces should be defined as global usings in GlobalUsings.cs for consistency.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.GlobalUsingsCommon));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeUsingDirective, SyntaxKind.UsingDirective);
    }

    [SuppressMessage("Design", "MA0051:Method is too long", Justification = "OK.")]
    private static void AnalyzeUsingDirective(
        SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        // Check if any type in the file has GeneratedCode attribute
        var root = context.Node.SyntaxTree.GetRoot(context.CancellationToken);
        var hasGeneratedCodeAttribute = root.DescendantNodes()
            .OfType<TypeDeclarationSyntax>()
            .Any(typeDecl => typeDecl.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString().Contains("GeneratedCode")));

        if (hasGeneratedCodeAttribute)
        {
            return;
        }

        var usingDirective = (UsingDirectiveSyntax)context.Node;

        // Skip if this is GlobalUsings.cs
        var fileName = Path.GetFileName(context.Node.SyntaxTree.FilePath);
        if (fileName.Equals("GlobalUsings.cs", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        // Skip if this is a global using (already in the correct place)
        if (usingDirective.GlobalKeyword.IsKind(SyntaxKind.GlobalKeyword))
        {
            return;
        }

        // Skip if this is a static using or alias
        if (usingDirective.StaticKeyword.IsKind(SyntaxKind.StaticKeyword) ||
            usingDirective.Alias is not null)
        {
            return;
        }

        // Get the namespace name
        var namespaceName = usingDirective.Name?.ToString();
        if (string.IsNullOrEmpty(namespaceName))
        {
            return;
        }

        // Get the configurable namespace prefixes from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(context.Node.SyntaxTree);
        var prefixes = options.GetNamespacePrefixes(RuleIdentifierConstants.Style.GlobalUsingsCommon);

        // Check if this namespace starts with any of the configured prefixes
        if (ShouldBeGlobalUsing(namespaceName!, prefixes))
        {
            var diagnostic = Diagnostic.Create(
                Rule,
                usingDirective.GetLocation(),
                namespaceName);

            context.ReportDiagnostic(diagnostic);
        }
    }

    private static bool ShouldBeGlobalUsing(string namespaceName, string[] prefixes)
    {
        return prefixes.Any(prefix =>
            namespaceName.StartsWith(prefix, StringComparison.Ordinal));
    }
}