namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class ParameterInlineAnalyzer : DiagnosticAnalyzer
{
    private const int MaxLineLength = 80;

    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.ParameterInline,
        title: "Single parameter should be kept inline when declaration is short",
        messageFormat: "Single parameter should be on the same line as the method declaration when total line length would not exceed {0} characters",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Enforces that single-parameter methods keep the parameter on the same line as the method declaration when the total line length would be under the maximum limit.",
        helpLinkUri: "https://github.com/atc-net/atc-analyzer/blob/main/docs/rules/ATC201.md");

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // Register for method declarations
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);

        // Register for constructor declarations
        context.RegisterSyntaxNodeAction(AnalyzeConstructorDeclaration, SyntaxKind.ConstructorDeclaration);

        // Register for local function declarations
        context.RegisterSyntaxNodeAction(AnalyzeLocalFunctionDeclaration, SyntaxKind.LocalFunctionStatement);

        // Register for delegate declarations
        context.RegisterSyntaxNodeAction(AnalyzeDelegateDeclaration, SyntaxKind.DelegateDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, methodDeclaration.ParameterList, methodDeclaration);
    }

    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var constructorDeclaration = (ConstructorDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, constructorDeclaration.ParameterList, constructorDeclaration);
    }

    private static void AnalyzeLocalFunctionDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var localFunctionDeclaration = (LocalFunctionStatementSyntax)context.Node;
        AnalyzeParameterList(context, localFunctionDeclaration.ParameterList, localFunctionDeclaration);
    }

    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var delegateDeclaration = (DelegateDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, delegateDeclaration.ParameterList, delegateDeclaration);
    }

    private static void AnalyzeParameterList(
        SyntaxNodeAnalysisContext context,
        ParameterListSyntax parameterList,
        SyntaxNode declarationNode)
    {
        if (parameterList is null || parameterList.Parameters.Count != 1)
        {
            return;
        }

        var parameter = parameterList.Parameters[0];
        var sourceText = declarationNode.SyntaxTree.GetText();

        // Get the line positions
        var declarationLineSpan = declarationNode.GetLocation().GetLineSpan();
        var declarationStartLine = declarationLineSpan.StartLinePosition.Line;

        var parameterLineSpan = parameter.GetLocation().GetLineSpan();
        var parameterStartLine = parameterLineSpan.StartLinePosition.Line;

        // Only check if parameter is on a different line than the declaration start
        if (parameterStartLine == declarationStartLine)
        {
            return;
        }

        // Calculate what the line length would be if the parameter was on the same line
        // Get the parameter text (just the parameter itself)
        var parameterText = parameter.ToString();

        // Get the line where the opening paren is located
        var openParenLineSpan = parameterList.OpenParenToken.GetLocation().GetLineSpan();
        var openParenLine = openParenLineSpan.StartLinePosition.Line;
        var openParenPosition = openParenLineSpan.StartLinePosition.Character;

        // Get the text of the line where the opening paren is
        var openParenLineText = sourceText.Lines[openParenLine].ToString();

        // The hypothetical line would be: everything up to and including '(' + parameter + ')'
        var textUpToAndIncludingOpenParen = openParenLineText.Substring(0, openParenPosition + 1);
        var hypotheticalLine = textUpToAndIncludingOpenParen + parameterText + ")";
        var hypotheticalLength = hypotheticalLine.Length;

        // If the hypothetical single-line length would be <= MaxLineLength, report a diagnostic
        if (hypotheticalLength <= MaxLineLength)
        {
            var diagnostic = Diagnostic.Create(
                Rule,
                parameterList.GetLocation(),
                MaxLineLength);
            context.ReportDiagnostic(diagnostic);
        }
    }
}