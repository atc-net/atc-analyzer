namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class ParameterInlineAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.ParameterInline,
        title: "Single parameter should be formatted correctly",
        messageFormat: "{0}",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "Enforces that single-parameter methods are formatted correctly based on line length.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.ParameterInline));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        // Register for method declarations
        context.RegisterSyntaxNodeAction(AnalyzeMethodDeclaration, SyntaxKind.MethodDeclaration);

        // Register for constructor declarations
        context.RegisterSyntaxNodeAction(AnalyzeConstructorDeclaration, SyntaxKind.ConstructorDeclaration);

        // Register for local function declarations
        context.RegisterSyntaxNodeAction(AnalyzeLocalFunctionDeclaration, SyntaxKind.LocalFunctionStatement);

        // Register for delegate declarations
        context.RegisterSyntaxNodeAction(AnalyzeDelegateDeclaration, SyntaxKind.DelegateDeclaration);
    }

    private static void AnalyzeMethodDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var methodDeclaration = (MethodDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, methodDeclaration.ParameterList, methodDeclaration);
    }

    private static void AnalyzeConstructorDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var constructorDeclaration = (ConstructorDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, constructorDeclaration.ParameterList, constructorDeclaration);
    }

    private static void AnalyzeLocalFunctionDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var localFunctionDeclaration = (LocalFunctionStatementSyntax)context.Node;
        AnalyzeParameterList(context, localFunctionDeclaration.ParameterList, localFunctionDeclaration);
    }

    private static void AnalyzeDelegateDeclaration(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var delegateDeclaration = (DelegateDeclarationSyntax)context.Node;
        AnalyzeParameterList(context, delegateDeclaration.ParameterList, delegateDeclaration);
    }

    private static void AnalyzeParameterList(
        SyntaxNodeAnalysisContext context,
        ParameterListSyntax parameterList,
        SyntaxNode declarationNode)
    {
        if (parameterList is null || parameterList.Parameters.Count != 1)
        {
            return;
        }

        // Get the configured max line length from .editorconfig
        var options = context.Options.AnalyzerConfigOptionsProvider.GetOptions(context.Node.SyntaxTree);
        var maxLineLength = options.GetMaxLineLength(RuleIdentifierConstants.Style.ParameterInline);

        var parameter = parameterList.Parameters[0];
        var sourceText = declarationNode.SyntaxTree.GetText();

        // Get the line where the opening paren is located
        var openParenLineSpan = parameterList.OpenParenToken.GetLocation().GetLineSpan();
        var openParenLine = openParenLineSpan.StartLinePosition.Line;
        var openParenPosition = openParenLineSpan.StartLinePosition.Character;

        var parameterLineSpan = parameter.GetLocation().GetLineSpan();
        var parameterStartLine = parameterLineSpan.StartLinePosition.Line;

        // Get the text of the line where the opening paren is
        var openParenLineText = sourceText.Lines[openParenLine].ToString();

        // Case 1: Parameter is on the SAME line as the opening paren
        if (parameterStartLine == openParenLine)
        {
            // Check if the actual line length exceeds the maximum
            if (openParenLineText.Length > maxLineLength)
            {
                // Line is too long, parameter should be broken to a new line
                var message = $"Single parameter should be on a new line when the method declaration exceeds {maxLineLength} characters";
                var diagnostic = Diagnostic.Create(
                    Rule,
                    parameterList.GetLocation(),
                    message);
                context.ReportDiagnostic(diagnostic);
            }

            return;
        }

        // Case 2: Parameter is on a DIFFERENT line than the opening paren
        // Calculate what the line length would be if the parameter was on the same line
        var parameterText = parameter.ToString();
        var textUpToAndIncludingOpenParen = openParenLineText.Substring(0, openParenPosition + 1);
        var hypotheticalLine = textUpToAndIncludingOpenParen + parameterText + ")";
        var hypotheticalLength = hypotheticalLine.Length;

        // If the hypothetical single-line length would be <= maxLineLength, parameter should be inline
        if (hypotheticalLength <= maxLineLength)
        {
            var message = $"Single parameter should be on the same line as the method declaration when total line length would not exceed {maxLineLength} characters";
            var diagnostic = Diagnostic.Create(
                Rule,
                parameterList.GetLocation(),
                message);
            context.ReportDiagnostic(diagnostic);
        }
    }
}