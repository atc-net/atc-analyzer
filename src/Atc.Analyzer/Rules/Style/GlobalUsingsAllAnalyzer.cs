namespace Atc.Analyzer.Rules.Style;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class GlobalUsingsAllAnalyzer : DiagnosticAnalyzer
{
    private static readonly DiagnosticDescriptor Rule = new(
        RuleIdentifierConstants.Style.GlobalUsingsAll,
        title: "Use global usings for all namespaces",
        messageFormat: "Using directive '{0}' should be moved to GlobalUsings.cs",
        RuleCategoryConstants.Style,
        DiagnosticSeverity.Warning,
        isEnabledByDefault: true,
        description: "All using directives should be defined as global usings in GlobalUsings.cs for consistency.",
        helpLinkUri: RuleIdentifierHelper.GetHelpUri(RuleIdentifierConstants.Style.GlobalUsingsAll));

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => [Rule];

    public override void Initialize(AnalysisContext context)
    {
        if (context is null)
        {
            throw new ArgumentNullException(nameof(context));
        }

        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeUsingDirective, SyntaxKind.UsingDirective);
    }

    private static void AnalyzeUsingDirective(SyntaxNodeAnalysisContext context)
    {
        if (context.Node.SyntaxTree.IsAutoGeneratedFile())
        {
            return;
        }

        var usingDirective = (UsingDirectiveSyntax)context.Node;

        // Skip if this is GlobalUsings.cs
        var fileName = Path.GetFileName(context.Node.SyntaxTree.FilePath);
        if (fileName.Equals("GlobalUsings.cs", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        // Skip if this is a global using (already in the correct place)
        if (usingDirective.GlobalKeyword.IsKind(SyntaxKind.GlobalKeyword))
        {
            return;
        }

        // Skip if this is a static using or alias
        if (usingDirective.StaticKeyword.IsKind(SyntaxKind.StaticKeyword) || usingDirective.Alias is not null)
        {
            return;
        }

        // Get the namespace name
        var namespaceName = usingDirective.Name?.ToString();
        if (string.IsNullOrEmpty(namespaceName))
        {
            return;
        }

        // All non-static, non-alias using directives should be global
        var diagnostic = Diagnostic.Create(
            Rule,
            usingDirective.GetLocation(),
            namespaceName);

        context.ReportDiagnostic(diagnostic);
    }
}