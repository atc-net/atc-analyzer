# üåê ATC220: Use global usings for all namespaces

## üìÇ Category

Style

## ‚ö†Ô∏è Severity

Warning

## üìñ Description

All using directives should be defined as global usings in GlobalUsings.cs for maximum consistency and minimal boilerplate across the codebase. This ensures every namespace import is centralized in one location.

## üìã Rules

1. **All namespaces**: Any using directive should be moved to GlobalUsings.cs
2. **Applies to**: Regular using directives only
3. **Does NOT apply to**:
   - Static using directives (`using static System.Console`)
   - Using aliases (`using Constants = Domain.Constants`)
   - Using directives already in GlobalUsings.cs
   - Generated code files

## üí° Motivation

Centralizing all namespace imports in GlobalUsings.cs provides several benefits:

- **Maximum boilerplate reduction**: Eliminates ALL repetitive using statements across files
- **Ultimate consistency**: Every file has access to the same namespaces
- **Single source of truth**: All namespace imports managed in one place
- **Cleanest files**: Individual files only need using aliases if required
- **Easiest maintenance**: Changes to namespace imports only need to be made once

This is the most aggressive global usings policy, suitable for projects where you want absolutely minimal boilerplate.

## üîÄ ATC220 vs ATC221: Which Rule to Use?

Both ATC220 and ATC221 enforce global usings, but they differ in scope and strictness:

| Aspect | ATC220 (Strict) | ATC221 (Lenient) |
|--------|----------------|------------------|
| **Policy** | All namespaces | Only System/Microsoft/Atc |
| **Flags** | Every using directive | Only common framework usings |
| **Third-party libs** | Must be in GlobalUsings.cs | Can stay in individual files |
| **Use when** | You want zero using statements in code files | You want flexibility for third-party dependencies |
| **Best for** | Highly controlled codebases, internal projects | Projects with many third-party libraries |

### When to Use ATC220 (This Rule)

Choose ATC220 if you want:

- **Maximum consistency**: Every file looks identical (no using statements at all)
- **Zero exceptions**: All usings centralized, no local decisions needed
- **Internal projects**: Where you control all dependencies
- **Minimal boilerplate**: Absolutely cleanest possible code files

### When to Use ATC221 Instead

Choose ATC221 if you want:

- **Flexibility**: Allow third-party usings to remain in individual files
- **Context clarity**: See third-party dependencies where they're used
- **Migration friendliness**: Easier to adopt incrementally
- **Library projects**: Where different files may use different third-party packages

### Configuration Example

You can enable only one rule at a time in your `.editorconfig`:

```ini
# Use strict policy (all usings must be global)
dotnet_diagnostic.ATC220.severity = warning
dotnet_diagnostic.ATC221.severity = none

# OR use lenient policy (only System/Microsoft/Atc must be global)
dotnet_diagnostic.ATC220.severity = none
dotnet_diagnostic.ATC221.severity = warning
```

**Note**: It's recommended to enable only one of these rules to avoid conflicting guidance.

## üìù Examples

### Scenario 1: All namespaces should be in GlobalUsings.cs

```csharp
// non-compliant - ANY namespace should be in GlobalUsings.cs
using System;
using Xunit;
using MyCompany.Utilities;

public class Sample
{
}

// compliant - GlobalUsings.cs contains all usings
public class Sample
{
}
```

### Scenario 2: Aliases are allowed locally

```csharp
// compliant - using aliases can remain in individual files
using Constants = Domain.Constants;

public class Sample
{
}
```

## ‚öôÔ∏è Configuration

This rule is not configurable. It applies to all using directives.

## üîß Code Fix

A code fix is available that automatically moves the using directive to GlobalUsings.cs.

**How to apply:**

1. Position cursor on the using directive
2. Click the lightbulb (üí°) or press `Ctrl+.` (Windows/Linux) or `Cmd+.` (Mac)
3. Select **"Move to GlobalUsings.cs"**

### GlobalUsings.cs Ordering Rule

The code fix ensures proper ordering in GlobalUsings.cs:

1. **System namespaces first** - All `System.*` namespaces are placed at the top, sorted alphabetically
2. **All other namespaces** - Everything else follows, sorted alphabetically

**Example ordering:**

```csharp
global using System;
global using System.Collections.Generic;
global using System.Linq;
global using System.Text;
global using Atc.Data;
global using Atc.Utilities;
global using Microsoft.Extensions.Logging;
global using Newtonsoft.Json;
global using Xunit;
```

This ensures consistency and makes it easy to locate specific namespace imports.

## üîó Related Rules

### Global Usings Policy

- **[ATC221: Use global usings for common namespaces](ATC221.md)** - Lenient policy: flags only System/Microsoft/Atc namespaces, allows third-party usings in individual files

### Other Style Rules

- [ATC201: Single parameter should be formatted correctly](ATC201.md) - Single parameter formatting
- [ATC202: Multi parameters should be separated on individual lines](ATC202.md) - Multi-parameter formatting
- [ATC203: Method chains with 2 or more calls should be placed on separate lines](ATC203.md) - Method chain formatting
- [ATC210: Use expression body syntax when appropriate](ATC210.md) - Expression body formatting
- [ATC230: Require exactly one blank line between code blocks](ATC230.md) - Blank line formatting
