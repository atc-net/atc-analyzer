# üåê ATC221: Use global usings for common namespaces

## üìÇ Category

Style

## ‚ö†Ô∏è Severity

Warning

## üìñ Description

Using directives for System, Microsoft, and Atc namespaces should be defined as global usings in GlobalUsings.cs for consistency and to reduce boilerplate across the codebase. This ensures all common namespace imports are centralized in one location.

## üìã Rules

1. **System namespaces**: Any using directive starting with `System` should be moved to GlobalUsings.cs
2. **Microsoft namespaces**: Any using directive starting with `Microsoft` should be moved to GlobalUsings.cs
3. **Atc namespaces**: Any using directive starting with `Atc` should be moved to GlobalUsings.cs
4. **Applies to**: Regular using directives only
5. **Does NOT apply to**:
   - Static using directives (`using static System.Console`)
   - Using aliases (`using SysConsole = System.Console`)
   - Using directives already in GlobalUsings.cs
   - Third-party namespaces (Xunit, Newtonsoft.Json, etc.)
   - Generated code files

## üí° Motivation

Centralizing common namespace imports in GlobalUsings.cs provides several benefits:

- **Reduces boilerplate**: Eliminates repetitive using statements across multiple files
- **Improves consistency**: Ensures all files have access to the same common namespaces
- **Easier maintenance**: Changes to common namespace imports only need to be made in one place
- **Cleaner files**: Individual files only need to declare third-party or project-specific usings
- **Better organization**: Clearly separates common framework usings from project-specific dependencies

This is particularly useful for large projects where the same namespaces (like `System.Linq`, `System.Collections.Generic`) are used throughout the codebase.

## üîÄ ATC220 vs ATC221: Which Rule to Use?

Both ATC220 and ATC221 enforce global usings, but they differ in scope and strictness:

| Aspect | ATC220 (Strict) | ATC221 (Lenient) |
|--------|----------------|------------------|
| **Policy** | All namespaces | Only System/Microsoft/Atc |
| **Flags** | Every using directive | Only common framework usings |
| **Third-party libs** | Must be in GlobalUsings.cs | Can stay in individual files |
| **Use when** | You want zero using statements in code files | You want flexibility for third-party dependencies |
| **Best for** | Highly controlled codebases, internal projects | Projects with many third-party libraries |

### When to Use ATC221 (This Rule)

Choose ATC221 if you want:

- **Flexibility**: Allow third-party usings to remain in individual files
- **Context clarity**: See third-party dependencies where they're used (Xunit, FluentAssertions, etc.)
- **Migration friendliness**: Easier to adopt incrementally in existing projects
- **Library projects**: Where different files may use different third-party packages
- **Balanced approach**: Centralize framework usings while keeping context for external dependencies

### When to Use ATC220 Instead

Choose ATC220 if you want:

- **Maximum consistency**: Every file looks identical (no using statements at all)
- **Zero exceptions**: All usings centralized, no local decisions needed
- **Internal projects**: Where you control all dependencies
- **Minimal boilerplate**: Absolutely cleanest possible code files

### Configuration Example

You can enable only one rule at a time in your `.editorconfig`:

```ini
# Use lenient policy (only System/Microsoft/Atc must be global)
dotnet_diagnostic.ATC220.severity = none
dotnet_diagnostic.ATC221.severity = warning

# OR use strict policy (all usings must be global)
dotnet_diagnostic.ATC220.severity = warning
dotnet_diagnostic.ATC221.severity = none
```

**Note**: It's recommended to enable only one of these rules to avoid conflicting guidance.

## üìù Examples

### Scenario 1: System namespaces should be in GlobalUsings.cs

#### System namespace

```csharp
// non-compliant - System namespace should be in GlobalUsings.cs
using System;

public class Sample
{
    public static void DoSomething()
    {
        Console.WriteLine("Hello");
    }
}

// compliant - GlobalUsings.cs contains: global using System;
public class Sample
{
    public static void DoSomething()
    {
        Console.WriteLine("Hello");
    }
}
```

#### System.Collections.Generic

```csharp
// non-compliant
using System.Collections.Generic;

public class Sample
{
    public static List<string> GetList() => new();
}

// compliant - GlobalUsings.cs contains: global using System.Collections.Generic;
public class Sample
{
    public static List<string> GetList() => new();
}
```

#### System.Linq

```csharp
// non-compliant
using System.Linq;

public class Sample
{
    public static int GetCount(int[] values) => values.Count();
}

// compliant - GlobalUsings.cs contains: global using System.Linq;
public class Sample
{
    public static int GetCount(int[] values) => values.Count();
}
```

### Scenario 2: Microsoft namespaces should be in GlobalUsings.cs

```csharp
// non-compliant
using Microsoft.Extensions.Logging;
using Microsoft.CodeAnalysis;

public class Analyzer
{
    // Implementation
}

// compliant - GlobalUsings.cs contains:
//   global using Microsoft.Extensions.Logging;
//   global using Microsoft.CodeAnalysis;
public class Analyzer
{
    // Implementation
}
```

### Scenario 3: Atc namespaces should be in GlobalUsings.cs

```csharp
// non-compliant
using Atc.Utilities;
using Atc.Data;

public class Sample
{
    // Implementation
}

// compliant - GlobalUsings.cs contains:
//   global using Atc.Utilities;
//   global using Atc.Data;
public class Sample
{
    // Implementation
}
```

### Scenario 4: Third-party namespaces are OK in local files

```csharp
// compliant - third-party namespaces can remain in individual files
using Xunit;
using FluentAssertions;
using Newtonsoft.Json;

public class Tests
{
    [Fact]
    public void TestMethod()
    {
        // Test implementation
    }
}
```

### Scenario 5: Static usings and aliases are allowed

```csharp
// compliant - static usings are allowed locally
using static System.Console;

public class Sample
{
    public static void Print()
    {
        WriteLine("Hello"); // No need for Console.
    }
}

// compliant - using aliases are allowed locally
using SysConsole = System.Console;

public class Sample
{
    public static void Print()
    {
        SysConsole.WriteLine("Hello");
    }
}
```

### Example GlobalUsings.cs

```csharp
// System namespaces come first, sorted alphabetically
global using System;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Linq;
global using System.Text;
// All other namespaces follow, sorted alphabetically
global using Atc.Extensions;
global using Microsoft.CodeAnalysis;
global using Microsoft.CodeAnalysis.CSharp;
global using Microsoft.CodeAnalysis.CSharp.Syntax;
```

## ‚öôÔ∏è Configuration

Configure the namespace prefixes to flag in `.editorconfig`:

```ini
[*.cs]
# Semicolon-separated namespace prefixes to flag (default: System;Microsoft;Atc)
dotnet_diagnostic.ATC221.namespace_prefixes = System;Microsoft;Atc;MyCompany
```

| Option | Default | Description |
|--------|---------|-------------|
| `namespace_prefixes` | `System;Microsoft;Atc` | Semicolon-separated list of namespace prefixes to flag for global usings |

**Example configurations:**

```ini
# Default - System, Microsoft, and Atc namespaces
dotnet_diagnostic.ATC221.namespace_prefixes = System;Microsoft;Atc

# Add custom company namespace
dotnet_diagnostic.ATC221.namespace_prefixes = System;Microsoft;Atc;MyCompany

# Only System namespaces
dotnet_diagnostic.ATC221.namespace_prefixes = System

# Multiple custom prefixes
dotnet_diagnostic.ATC221.namespace_prefixes = System;Microsoft;Atc;Contoso;Fabrikam
```

**Use cases:**

- **Add company namespace**: If your company has a root namespace (e.g., `MyCompany.*`), add it to ensure all your internal namespaces are also moved to GlobalUsings.cs
- **Reduce scope**: If you only want System namespaces to be flagged, configure just `System`
- **Third-party framework**: If you have a heavily-used third-party framework, you can add its namespace prefix

## ü§ñ Generated Code

This rule automatically skips analysis of generated code. Generated code is identified by:

1. **GeneratedCode Attribute**: Classes or types marked with `[GeneratedCode]` attribute from `System.CodeDom.Compiler`
2. **Auto-generated Headers**: Files containing "auto-generated" in header comments (case-insensitive)

Example of skipped code:

```csharp
using System.CodeDom.Compiler;

[GeneratedCode("MyCodeGenerator", "1.0")]
public class GeneratedClass
{
    // Using directives in generated code are ignored
}
```

```csharp
//------------------------------------------------------------------------------
// This code was auto-generated by ApiGenerator 2.0.
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;

public class AutoGeneratedClass
{
    // Using directives in auto-generated files are ignored
}
```

## üîß Code Fix

A code fix is available that automatically moves the using directive to GlobalUsings.cs.

**How to apply:**

1. Position cursor on the using directive that should be in GlobalUsings.cs
2. Click the lightbulb (üí°) or press `Ctrl+.` (Windows/Linux) or `Cmd+.` (Mac)
3. Select **"Move to GlobalUsings.cs"**

The code fix will:

- Remove the using directive from the current file
- Add it as a global using directive to GlobalUsings.cs
- If GlobalUsings.cs doesn't exist, it will be created
- Insert the new global using following the ordering rule (System namespaces first, then all others alphabetically)
- Prevent duplicate entries if the using already exists in GlobalUsings.cs

### GlobalUsings.cs Ordering Rule

The code fix ensures proper ordering in GlobalUsings.cs:

1. **System namespaces first** - All `System.*` namespaces are placed at the top, sorted alphabetically
2. **All other namespaces** - Everything else follows, sorted alphabetically

**Example ordering:**

```csharp
global using System;
global using System.Collections.Generic;
global using System.Linq;
global using System.Text;
global using Atc.Data;
global using Atc.Extensions;
global using Microsoft.CodeAnalysis;
global using Microsoft.Extensions.Logging;
```

This ensures consistency and makes it easy to locate specific namespace imports.

**Example:**

```csharp
// Before code fix - MyClass.cs
using System;
using Microsoft.Extensions.Logging;
using Xunit;

public class MyClass
{
    // Implementation
}

// After code fix - MyClass.cs (System and Microsoft moved to GlobalUsings.cs)
using Xunit;

public class MyClass
{
    // Implementation
}

// GlobalUsings.cs (updated with proper ordering)
global using System;
global using System.Collections.Generic;
global using Atc.Extensions;
global using Microsoft.Extensions.Logging; // <-- Added here, after all other namespaces alphabetically
```

**Batch fix:**
You can apply the fix to multiple files at once:

1. Right-click on the project or solution in Solution Explorer
2. Select "Analyze and Code Cleanup" ‚Üí "Run Code Cleanup"
3. All System/Microsoft/Atc using directives will be moved to GlobalUsings.cs

## üîó Related Rules

### Global Usings Policy

- **[ATC220: Use global usings for all namespaces](ATC220.md)** - Strict policy: flags ALL using directives, requires all namespaces in GlobalUsings.cs

### Other Style Rules

- [ATC201: Single parameter should be formatted correctly](ATC201.md) - Single parameter formatting
- [ATC202: Multi parameters should be separated on individual lines](ATC202.md) - Multi-parameter formatting
- [ATC203: Method chains with 2 or more calls should be placed on separate lines](ATC203.md) - Method chain formatting
- [ATC210: Use expression body syntax when appropriate](ATC210.md) - Expression body formatting
- [ATC230: Require exactly one blank line between code blocks](ATC230.md) - Blank line formatting
