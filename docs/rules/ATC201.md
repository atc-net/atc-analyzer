# üìè ATC201: Single parameter should be formatted correctly

## üìÇ Category

Style

## ‚ö†Ô∏è Severity

Warning

## üìñ Description

Enforces proper formatting for single-parameter method declarations based on line length. Parameters should be inline when the total line length is under 80 characters, or on a separate line when it exceeds 80 characters. This rule ensures consistent and readable code.

## üìã Rules

1. **Short declarations (‚â§ 80 characters)**: If the entire declaration (including parameter) would fit within 80 characters, the parameter must be on the same line
2. **Long declarations (> 80 characters)**: If the declaration exceeds 80 characters, the parameter must be broken to a separate line
3. **Applies to**: Method declarations, constructor declarations, local functions, and delegate declarations with exactly one parameter
4. **Does NOT apply to**: Methods with multiple parameters (handled by ATC202), method invocations, lambda expressions

## üí° Motivation

Proper formatting of single-parameter declarations:
- **For short lines**: Improves code readability by reducing unnecessary vertical space
- **For long lines**: Prevents horizontal scrolling and maintains readability
- Makes method signatures more scannable
- Maintains consistency with common C# conventions
- Reduces visual clutter in codebases

This rule works in tandem with ATC202 (which handles multiple parameters) to provide comprehensive parameter formatting guidance.

## üìù Examples

### Scenario 1: Short declarations - Parameter should be inline

#### Single short parameter

```csharp
// non-compliant - parameter unnecessarily broken to new line
public void Process(
    int id)
{
    // Implementation
}

// compliant - parameter is inline
public void Process(int id)
{
    // Implementation
}
```

#### Short constructor with parameter

```csharp
// non-compliant
public class Customer
{
    public Customer(
        string name)
    {
        // Implementation
    }
}

// compliant
public class Customer
{
    public Customer(string name)
    {
        // Implementation
    }
}
```

#### Short method with nullable parameter

```csharp
// non-compliant
public void Handle(
    string? message)
{
    // Implementation
}

// compliant
public void Handle(string? message)
{
    // Implementation
}
```

### Scenario 2: Long declarations - Parameter should be broken

#### Long method name exceeding 80 characters

```csharp
// non-compliant - line exceeds 80 characters
public void MyVeryLongMethodNameThatExceedsTheLineLimitWithParameter(int parameter)
{
    // Implementation
}

// compliant - parameter broken to new line
public void MyVeryLongMethodNameThatExceedsTheLineLimitWithParameter(
    int parameter)
{
    // Implementation
}
```

#### Method with long parameter and default value

```csharp
// non-compliant - exceeds 80 characters
public static DataTable CreateKeyValueDataTableOfIntString(DropDownFirstItemType dropDownFirstItemType = DropDownFirstItemType.None)
{
    // Implementation
}

// compliant - parameter broken to new line
public static DataTable CreateKeyValueDataTableOfIntString(
    DropDownFirstItemType dropDownFirstItemType = DropDownFirstItemType.None)
{
    // Implementation
}
```

#### Method with attributes (attributes don't affect line length)

```csharp
// compliant - attributes on separate lines don't count towards the declaration line length
[SuppressMessage("Design", "CA1019:Define accessors for attribute arguments", Justification = "OK.")]
public EnumGuidAttribute(string value)
{
    GlobalIdentifier = new Guid(value);
}

// also compliant - the opening paren line is evaluated independently
[SuppressMessage("Design", "CA1019:Define accessors for attribute arguments", Justification = "OK.")]
public void Process(
    int id)
{
    // Implementation (parameter should still be inline per Scenario 1)
}
```

**Note**: The analyzer evaluates the line containing the opening parenthesis, not lines with attributes above the declaration.

## ‚öôÔ∏è Configuration

The maximum line length threshold is set to 80 characters by default and is currently not configurable.

## ü§ñ Generated Code

This rule automatically skips analysis of generated code. Generated code is identified by:

1. **GeneratedCode Attribute**: Classes or types marked with `[GeneratedCode]` attribute from `System.CodeDom.Compiler`
2. **Auto-generated Headers**: Files containing "auto-generated" in header comments (case-insensitive)

Example of skipped code:

```csharp
using System.CodeDom.Compiler;

[GeneratedCode("MyCodeGenerator", "1.0")]
public class GeneratedClass
{
    // This would normally violate ATC201, but is ignored
    public void Method(
        int parameter)
    {
    }
}
```

```csharp
//------------------------------------------------------------------------------
// This code was auto-generated by ApiGenerator 2.0.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//------------------------------------------------------------------------------

public class AutoGeneratedClass
{
    // This would normally violate ATC201, but is ignored
    public void Method(
        int parameter)
    {
    }
}
```

## üîß Code Fix

Currently, no automatic code fix is available for this rule. Manual correction is required.

## üîó Related Rules

- [ATC202: Multi parameters should be separated onto individual lines](ATC202.md) - Complementary rule that enforces parameter separation for multiple parameters or long lines
