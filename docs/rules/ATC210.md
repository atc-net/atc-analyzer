# ðŸ”— ATC210: Use expression body syntax when appropriate

## ðŸ“‚ Category

Style

## âš ï¸ Severity

Warning

## ðŸ“– Description

Enforces the use of expression body syntax (=>) for methods and properties with simple return statements. This rule ensures consistent and concise code by requiring expression bodies when appropriate, while also enforcing proper formatting for longer expressions.

## ðŸ“‹ Rules

1. **Methods with single return statement**: Methods containing only a return statement with an expression should use expression body syntax (`=>`) instead of block body syntax (`{ return ... }`)
2. **Property accessors with single return statement**: Get/set accessors containing only a return statement should use expression body syntax
3. **Line length threshold**: Expression bodies that exceed 80 characters on a single line must place the `=>` arrow on a new line
4. **Multi-line expressions**: Complex expressions (like ternary operators) that span multiple lines should have the `=>` arrow on a new line for better readability
5. **Applies to**: Methods, property accessors (get/set), and property declarations
6. **Does NOT apply to**: Void methods (methods with no return value), methods with multiple statements, constructors, or methods with complex logic

## ðŸ’¡ Motivation

Using expression body syntax:
- Makes code more concise and readable for simple operations
- Reduces visual clutter by eliminating unnecessary braces and return keywords
- Follows modern C# coding conventions and idiomatic patterns
- Maintains consistency across the codebase
- Proper formatting (arrow on new line for long expressions) prevents horizontal scrolling and improves readability

## ðŸ“ Examples

### Methods with simple return statement

```csharp
// non-compliant
public static string GetData()
{
    return "Sample Data";
}

// compliant
public static string GetData() => "Sample Data";

// also compliant (multi-line format)
public static string GetData()
    => "Sample Data";
```

### Methods with expressions

```csharp
// non-compliant
public static int Calculate(int x, int y)
{
    return x + y;
}

// compliant
public static int Calculate(int x, int y) => x + y;
```

### Methods with method calls

```csharp
// non-compliant
public static string GetUpperCase(string input)
{
    return input.ToUpper();
}

// compliant
public static string GetUpperCase(string input) => input.ToUpper();
```

### Methods with ternary expressions

```csharp
// non-compliant
public static int GetValue(bool condition)
{
    return condition ? 1 : 0;
}

// compliant
public static int GetValue(bool condition) => condition ? 1 : 0;
```

### Expression bodies exceeding 80 characters

```csharp
// non-compliant - expression exceeds 80 characters on single line
public static string GetLongData() => "Sample Dataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";

// compliant - arrow moved to new line
public static string GetLongData()
    => "Sample Dataaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
```

### Multi-line ternary expressions

```csharp
// non-compliant - arrow on same line as method declaration with multi-line expression
private static string[] SetArgs(string[] args) =>
    args.Length == 0
        ? new[] { "help" }
        : args;

// compliant - arrow on new line for multi-line ternary
private static string[] SetArgs(string[] args)
    => args.Length == 0
        ? new[] { "help" }
        : args;
```

### Property accessors

```csharp
// non-compliant
private string name = string.Empty;

public string Name
{
    get
    {
        return name;
    }
}

// compliant
private string name = string.Empty;

public string Name
{
    get => name;
}

// also compliant (read-only property)
public string Name => name;
```

### Properties with multi-line format

```csharp
// compliant - short expression on single line
public string Name => "Sample";

// compliant - arrow on new line
public string Description
    => "Sample description";
```

### Async methods

```csharp
// non-compliant
public static async Task<string> GetDataAsync()
{
    return await Task.FromResult("data");
}

// compliant
public static async Task<string> GetDataAsync()
    => await Task.FromResult("data");
```

### Generic methods

```csharp
// non-compliant
public static T GetDefault<T>()
{
    return default(T)!;
}

// compliant
public static T GetDefault<T>()
    => default(T)!;
```

### Methods with lambda returns

```csharp
// non-compliant
public static Func<int, int> GetMultiplier(int factor)
{
    return x => x * factor;
}

// compliant
public static Func<int, int> GetMultiplier(int factor) => x => x * factor;
```

### Methods that should NOT use expression body

```csharp
// compliant - multiple statements require block body
public static string GetProcessedData()
{
    var data = "Sample";
    return data.ToUpper();
}

// compliant - complex logic requires block body
public static int Calculate(int value)
{
    if (value > 0)
    {
        return value * 2;
    }
    return 0;
}

// compliant - void method (no return value)
public static void DoSomething()
{
    Console.WriteLine("Hello");
}

// compliant - method with loop
public static int Sum(int[] values)
{
    var sum = 0;
    foreach (var value in values)
    {
        sum += value;
    }
    return sum;
}
```

## âš™ï¸ Configuration

This rule is not configurable. The line length threshold is fixed at 80 characters.

## ðŸ¤– Generated Code

This rule automatically skips analysis of generated code. Generated code is identified by:

1. **GeneratedCode Attribute**: Classes or types marked with `[GeneratedCode]` attribute from `System.CodeDom.Compiler`
2. **Auto-generated Headers**: Files containing "auto-generated" in header comments (case-insensitive)

Example of skipped code:

```csharp
using System.CodeDom.Compiler;

[GeneratedCode("MyCodeGenerator", "1.0")]
public class GeneratedClass
{
    public string GetData()
    {
        return "data"; // This would normally violate ATC210, but is ignored
    }
}
```

```csharp
//------------------------------------------------------------------------------
// This code was auto-generated by ApiGenerator 2.0.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//------------------------------------------------------------------------------

public class AutoGeneratedClass
{
    public string GetData()
    {
        return "data"; // This would normally violate ATC210, but is ignored
    }
}
```

## ðŸ”§ Code Fix

A code fix is available that automatically converts block bodies to expression bodies and formats expression bodies with proper line breaks.

**How to apply:**
1. Position cursor on the method or accessor that violates the rule
2. Click the lightbulb (ðŸ’¡) or press `Ctrl+.` (Windows/Linux) or `Cmd+.` (Mac)
3. Select either:
   - **"Use expression body"** - Converts block body with single return statement to expression body
   - **"Move '=>' to new line"** - Reformats expression body to place arrow on new line for long expressions

The code fix will:
- Convert block bodies (`{ return x; }`) to expression bodies (`=> x`)
- Remove unnecessary braces, semicolons, and return keywords
- Apply proper spacing around the `=>` arrow
- For long expressions (>80 characters), place the arrow on a new line with proper indentation
- For multi-line expressions (e.g., ternary operators), format the arrow and expression on separate lines
- Preserve all expression logic and comments
- Work with methods, properties, and property accessors

**Example - Convert to expression body:**
```csharp
// Before code fix
public static string GetData()
{
    return "Sample Data";
}

// After code fix (automatic)
public static string GetData() => "Sample Data";
```

**Example - Move arrow to new line (long expression):**
```csharp
// Before code fix
public static string GetData() => "Very long sample data that exceeds the 80 character limit";

// After code fix (automatic)
public static string GetData()
    => "Very long sample data that exceeds the 80 character limit";
```

**Example - Multi-line ternary expression:**
```csharp
// Before code fix
private static string[] SetArgs(string[] args) =>
    args.Length == 0
        ? new[] { "help" }
        : args;

// After code fix (automatic)
private static string[] SetArgs(string[] args)
    => args.Length == 0
        ? new[] { "help" }
        : args;
```

## ðŸ”— Related Rules

- [ATC201: Single parameter should be kept inline when declaration is short](ATC201.md) - Parameter formatting for method declarations
- [ATC202: Multi parameters should be separated on individual lines](ATC202.md) - Parameter formatting for multiple parameters
- [ATC203: Method chains with 2 or more calls should be placed on separate lines](ATC203.md) - Method chain formatting
